from __future__ import division
from gekko import GEKKO
import numpy as np
import random
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import pandas as pd  # data science library
from scipy.optimize import minimize

"""
modos de modelo 

Imode=5,6 usa colocacion ortogonal de elementos finitos 
para resolver implicitamente el sistema diferencial algebraico 
metodos simultaneos no simulados 
a la vez optimizan el objetivo e implicitamente calculan
los límites del modelo 
estos métodos tienden a ser efectivos en problemas con muchos grados 
de libertad 
"""

"""
metodos secuenciales separan el NLP optimizer 
(non linear programing) del simulador DAE( diferrential algebraic equation
)
métodos secuenciales satisfacen las ecuaciones diferenciales y algebraicas

incluso donde el solucionador es incapaz de encontrar una 
solución óptima factible


los modos no dinámicos configuran todos los terminos 
diferenciales a cero para calcular condiciones en un estado estable 
"""

"""
Modos 
estado estable de simulación 
(IMODE=1) soluciona el sistema cuando t=0

IMODE)4= simultaneous 
I MODE 7= sequential 


Imode 5,6 metodos no simulados simultaneos usas colocacion ortongonal para resolver el sistema DAE para sistemas con muchos 
grados de dificultad 



multimodal functions have mora than one optima, it means that can  either have a single or more than one global optima 
  
  
heuristic 


in DOE problems we have to minimize this function: 

||ym-y||n
 subject to constraints
 
  PSO was proposed by Eberhart and Kennedy in 1995 
  
   mejoras del algoritmo proposiciones 
   hibiridas 
   cambio en la estructura de los pesos y del optimo global 
   
   
   model: Artificial neural network (Ann) is a model that simulates tha human brain learning and memory 
   el algoritmo PSO es usado para mejorar la habilidad de aprendizaje de la red neuronal 
   
   enhance=mejorar
   Therefore=por lo tanto 
    
   
      
"""

"""
ecuacion principal que se maneja en el algoritmo PSO 

V=velocidad de la particula 
w= es el peso de la particula 
c1 y c2 son parámetros de escabilidad cognitiva y social respectivamente 
r1 y r2 son dos números aleatorios que estan uniformememtne distribuidos en un intervalo de [0,1]

Vi(t+1)=w(t)Vi(t)+c1* r1(pbesti(t)-Xi(t)+c2*r2(gbest(t)-Xi(t)))
Xi(t+1)=Xi(t)+Vi(t+1)
"""

data = np.array(pd.read_csv("NoisyData.csv"))

# %% pasos
"""
1. Indicar el número de iteraciones 
2. Indicar los parametros iniciales del modelo depende especificamente del modelo 
3. bias update 
4. indicar el horizonte el estimador 



Descripcion del modelo a resolver 

objetivo: entener el efecto de la mala data en
algoritmos de optimización dinámica  incluyendo 
estimadores y controles 

El caudal de barro y material es especialmente importante 
en la perforación  de presión controlada para asi 
detectar la entrada de gas o perdidas de fluidos. 
Hay una variedad de instrumentos de medición para flujos 
como lo es metro de flujo de masa o el flujo coriolis 







"""
# initial parameters
n_iter = 150  # number of cycles epocas iteraciones
x = 37.727  # true value valor exacto teórico del modelo
# filtered bias update
alpha = 0.0951
# mhe tuning moving horizon estimator
horizon = 30

# %% Model

# Iniatilize model

m = GEKKO(remote=True)

# solve options

rmt = True  # Remote: true or false

# specify server

m.server = 'https://byu.apmonitor.com'

# time array

"""
vector de un incremento 
de 0 hasta 49 total 50 elementos 

"""
m.time = np.arange(50)

# Parameters
# u valvula
u = m.Param(value=42)
# disturbance
d = m.FV(value=0)  # FV fixed variable
# cv = 1 valor constante en el modelo
Cv = m.Param(value=1)
# constante del modelo
tau = m.Param(value=0.1)

# Variable

# flujo F1

flow = m.CV(value=42)

# Equation
m.Equation(tau * flow.dt() == -flow + Cv * u + d)

# Options


m.options.imode = 5  # modo para sistemas simultaneos no-simulados

m.options.ev_type = 1  # estimated variable error 1 = norma uno 2= norma 2 tres= aprozimación lineal

m.options.coldstart = 1  # CV FV values are turned to 0 temporarily para reducir el numero de grados de libertad del modelo

m.options.solver = 1

d.status = 1
flow.fstatus = 1
flow.wmeas = 100
flow.wmodel = 0

# flow.dcost=0


# Initialize L1 application

m.solve()

# %% Other setup
# Create storage for results

xtrue = x * np.ones(n_iter + 1)
z = x * np.ones(n_iter + 1)  # measurements
time = np.zeros(n_iter + 1)
xb = np.empty(n_iter + 1)
x1mhe = np.empty(n_iter + 1)
x2mhe = np.empty(n_iter + 1)

# initial estimator values


x0 = 40
xb[0] = x0
x1mhe[0] = x0
x2mhe[0] = x0

# DATA

# outliers
for i in range(n_iter + 1):
    z[i] = x + (random.random() - 0.5) * 2.0
z[50] = 100
z[100] = 0

# %% L1 Application

##Cycle through measurement sequentally

for k in range(1, n_iter + 1):
    print('Cycle' + str(k) + ' of ' + str(n_iter))
    time[k] = k

    # L1-norm MHE
    flow.meas = z[k]
    m.solve()
    x1mhe[k] = flow.model

print("Finished L1")

# clar L1 //
m.clear_data()

# Options for L2
m.options.ev_type = 2  # start with l1 norm
m.options.coldstart = 1  # reinitialize
flow.wmodel = 10

# %% L2 Application

m.solve()

## Cycle through measurement sequentally

for k in range(1, n_iter + 1):
    print('Cycle' + str(k) + ' of ' + str(n_iter))
    time[k] = k

    # L2-norm MHE
    flow.meas = z[k]
    m.solve()
    x2mhe[k] = flow.model
